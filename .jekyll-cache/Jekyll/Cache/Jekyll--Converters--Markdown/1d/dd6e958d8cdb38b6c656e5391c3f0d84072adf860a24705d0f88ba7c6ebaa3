I"e6<h1 id="fastapi">FastAPI</h1>

<p>FastAPI는 Starlette라는 비동기 프레임워크를 기반으로 만들어졌고, 비동기 처리로 uvloop라는 Cython으로 만들어진 libuv 라이브러리를 사용한다.</p>

<ul>
  <li>
    <p>Asyncio</p>

    <p>Python 표준 라이브러리와 함께 제공되는 비동기 프레임워크이다.</p>
  </li>
  <li>
    <p>uvloop</p>

    <p>asyncio를 대체하기 위해 만들어졌다. uvloop는 Cython으로 작성되었으며 libuv 위에 구축되었다. (libuv는 nodeJS에서 사용하는 고성능 다중 플랫폼 비동기 I/O 라이브러리이다.)</p>
  </li>
</ul>

<h1 id="fastapi-구성-요소">FastAPI 구성 요소</h1>

<blockquote>
  <p>Uvicorn</p>

</blockquote>

<p>초고속 ASGI Web Server이다. 단일 프로세스에서 uvloop기반 비동기 Python code를 실행한다.</p>

<blockquote>
  <p>Starlette</p>

</blockquote>

<p>비동기적으로 실행할 수 있는 Web Application Server이다. Uvicorn위에서 실행된다.</p>

<ul>
  <li>Web Application Server : DB 조회 및 다양한 로직 처리 요구시 동적인 컨텐츠를 제공하기 위해 만들어진 어플리케이션 서버.</li>
  <li>기능
    <ol>
      <li>프로그램 실행 환경 및 DB 접속 기능 제공</li>
      <li>여러 트랜잭션 관리 기능</li>
      <li>업무를 처리하는 비즈니스 로직 수행</li>
    </ol>
  </li>
</ul>

<h2 id="장점">장점</h2>

<ul>
  <li>빠르다.(Starlette 와 Pydantic 덕분에) NodeJS 및 Go와 대등할 정도로 빠름.</li>
  <li><strong>빠른 코드 작성</strong>: 약 200%에서 300%까지 기능 개발 속도 증가. *</li>
  <li><strong>적은 버그</strong>: 사람(개발자)에 의한 에러 약 40% 감소. *</li>
  <li>
    <p><strong>직관적</strong>: 훌륭한 편집기 지원. 모든 곳에서 . 적은 디버깅 시간.</p>

    <p>자동완성</p>
  </li>
  <li><strong>쉬움</strong>: 쉽게 사용하고 배우도록 설계. 적은 문서 읽기 시간.</li>
  <li><strong>짧음</strong>: 코드 중복 최소화. 각 매개변수 선언의 여러 기능. 적은 버그.</li>
  <li><strong>견고함</strong>: 준비된 프로덕션 용 코드를 얻으십시오. 자동 대화형 문서와 함께.</li>
  <li><strong>표준 기반</strong>: API에 대한 (완전히 호환되는) 개방형 표준 기반: <a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a> (이전에 Swagger로 알려졌던) 및 <a href="http://json-schema.org/">JSON 스키마</a>.</li>
</ul>

<p>개인적으로 특히 Swagger UI가 편했다. POST, GET 등의 API 호출의 결과를 확인하기 위해서는 Postman을 사용했었는데 FastAPI는 그럴 필요 없이 /docs 를 붙이기만마녀 Swagger UI로 바로 이동되어서 편했다.</p>

<h2 id="path-parameter-query-parameter">Path Parameter, Query Parameter</h2>

<p>웹에서 Get Method를 통해 데이터를 전송할 수 있음. id가 402인 사용자의 정보를 가져오려 할 때</p>

<ul>
  <li>
    <p>Path Parameter</p>

    <p>/users/402 : 서버에 402라는 값을 전달하고 변수로 사용한다.</p>
  </li>
  <li>
    <p>Query Parameter</p>

    <p>/users?id=402</p>

    <p>Query String</p>

    <p>API 뒤에 입력 데이터를 함께 제공하는 방식으로 사용</p>

    <p>Query String은 Key, Value의 쌍으로 이루어지며 &amp;로 연결해 여러 데이터를 넘길 수 있다.</p>

    <p>어떤 Resource를 식별하고 싶은 경우에는 Path Parameter, 정렬, 필터링 해야 하는 경우에는 Query Parameter가 더 적합하다.</p>

    <ul>
      <li>
        <p>이유는?</p>

        <p>예를들어 users/402 를 했을 때 402라는 유저가 없는경우 Path Parameter는 404 not found를 반환한다.</p>

        <p>하지만 users?id=402 를 했을 때 402라는 유저가 없는 경우 Query Parameter는 빈 리스트를 반환하기 때문에 error handling과정이 추가로 필요하기 때문이다.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="path-parameter">Path Parameter</h3>

<ul>
  <li>Get Method: 정보를 READ하기 위해 사용</li>
  <li>유저 정보에 접근하는 API 만들기</li>
  <li>FastAPI는 데코레이터로 GET,POST를 표시</li>
  <li>@app.get @app.post</li>
  <li>Get Method의 인자로 있는 {user_id}가 함수의 값으로 주입</li>
</ul>

<h3 id="query-parameter">Query Parameter</h3>

<ul>
  <li>함수의 파라미터가 Query Parameter로 사용됨URL뒤에 ?를 붙이고 Key, Value형태로 연결</li>
</ul>

<h3 id="optional-parameter">Optional Parameter</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from typing import Optional
</code></pre></div></div>

<h2 id="request-body">Request Body</h2>

<ul>
  <li>POST 메서드는 Request Body에 데이터를 넣어 보낸다.</li>
  <li>Body의 데이터를 설명하는 Content-Type이란 Header 필드가 존재하고, 어떤 데이터 타입인지 명시해야 한다.</li>
</ul>

<h2 id="pydantic">Pydantic</h2>

<ul>
  <li>FastAPI에서 Class사용할 때 보이던 Pydantic // BaseModel</li>
  <li>Data Validation / Settion Management라이브러리</li>
  <li>Type Hint를 런타임에서 강제해 안전하게 데이터 핸들링</li>
  <li>파이썬 기본 타입(String,Int 등) + List, Dict, Tuple에 대한 Validation 지원</li>
  <li>기존 Validation 라이브러리보다 빠름(Benchmark)</li>
  <li>Config를 효과적으로 관리하도록 도와줌</li>
  <li>머신러닝 Feature Data Validation으로도 활용 가능</li>
  <li>
    <p>Pydantic의 두 가지 기능</p>

    <blockquote>
      <p>Validation</p>

      <ul>
        <li>Machine Learning Model Input Validation</li>
        <li>Online Serving에서 Input 데이터를 Validation 하는 Case</li>
      </ul>
    </blockquote>

    <p>조건 1: 올바른 url을 입력받음</p>

    <p>조건 2: 1~10 사이의 정수를 입력 받음</p>

    <p>조건 3: 올바른 폴더 이름을 입력 받음</p>

    <p>사용할 수 있는 방법</p>

    <ol>
      <li>일반 Python Class를 활용한 Input Definition 및 Validation</li>
      <li>Dataclass를 활용한 Input Definition 및 Validation</li>
      <li>Pydantic을 활용한 Input Definition 및 Validation</li>
    </ol>

    <p><strong>Pydantic Validation - Dataclass 활용시</strong></p>

    <ul>
      <li>dataclass decorator사용으로 init method를 따로 작성할 필요가 없어짐</li>
      <li>post init메서드 같은 편의매직메서드 사용 가능</li>
      <li>하지만 여전히 validate method를 따로 만들어야함(길어지는 검증 로직을 분리하기 위해)</li>
      <li>post init method 사용으로 따로 validate메서드를 호출하지 않아도 생성 시점에서 validation</li>
      <li>인스턴스 생성 시점에서 Validation을 수행하기 쉬움</li>
      <li>여전히 Validation 로직들을 직접 작성해야 함</li>
      <li>Validation 로직을 따로 작성하지 않으면, 런타임에서 type checking을 지원하지 않음</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  from pydantic import BaseModel, HttpUrl, Field, DirectoryPath
    
  class ModelInput03(BaseModel):
  	url: HttpUrl
      rate: int = Field(ge=1, le=10)
      target_dir: DirectoryPath
</code></pre></div>    </div>

    <p><strong>Pydantic Config</strong></p>

    <ul>
      <li>Pydantic은 Config을 체계적으로 관리할 방법을 제공</li>
      <li>기존에 다른 라이브러리들은 어떻게 Config를 설정하고 있을까?</li>
      <li>애플리케이션은 종종 설정을 상수로 코드에 저장함 <strong>==하드코딩</strong></li>
      <li>이것은 Twelve-Factor를 위반</li>
      <li>Twelve-Factor는 성정을 코드에서 엄격하게 분리하는 것을 요구함</li>
      <li>Twelve-Factor App은 설정을 환경 변수(envvars나 env라고도 불림)에 저장함</li>
      <li>환경 변수는 코드 변경 없이 쉽게 배포 때마다 쉽게 변경할 수 있음</li>
      <li><strong><em>코드랑 환경변수는 나눌 수 있다</em></strong></li>
      <li>The Twelve-Factor App이라는 Saas(Software as a Service)를 만들기 위한 방법론을 정리한 규칙들에 따르면, 환경설정은 애플리케이션 코드에서 분리되어 관리되어야 함</li>
    </ul>

    <p><a href="https://12factor.net/ko/config">12-factor</a></p>

    <ol>
      <li>.ini, .yaml파일 등으로 config 설정하기yaml로 환경 설정을 관리할 경우 쉽게 환경을 설정할 수 있지만, 환경에 대한 설정을 코드 하드코딩하는 형태때문에 변경사항이 생일 때 유연하게 코드를 변경하기 어려움</li>
      <li>Flask-style config.py
        <ul>
          <li>Config클래스에서 yaml, ini 파일을 불러와 python class필드로 주입하는 과정을 구현</li>
          <li>Config를 상속한 클래스에서는 Config클래스의 정보를 오버라이딩해서 사용</li>
          <li>하지만 해당파일의 데이터가 정상적인지 체크하거나(Validation)또는 환경 변수로부터 해당 필드를 오버라이딩하려면 코드량이 늘어난다.</li>
        </ul>
      </li>
      <li>pydantic base settings
        <ul>
          <li>Validation처럼 Pydantic은 BaseSettings를 상속한 클래스에서 Type Hint로 주입된 설정 데이터를 검증할 수 있음</li>
          <li>Field클래스의 env인자로, 환경변수로부터 해당 필드를 오버라이딩 할 수 있음</li>
          <li>yaml, ini파일들을 추가적으로 만들지 않고, .env파일들을 환경별로 만들어두거나, 실행환경에서 유연하게 오버라이딩 할 수 있음</li>
        </ul>
      </li>
    </ol>

    <p>## Starlette</p>

    <ul>
      <li>Starlette는 비동기적으로 실행할 수있는 Web application server 이다. Starlette는 Uvicorn 위에서 실행된다.</li>
      <li>FastAPI를 사용하지 않고 Starlette만 사용했다면, 모든 <strong>데이터 유효성 검사</strong> 및 <strong>직렬화</strong>를 직접 구현해야합니다.이 때문에 최종 애플리케이션은 FastAPI를 사용하여 빌드하는 것과 동일한 오버 헤드를 갖습니다. 그리고 대부분의 경우, <strong>데이터 유효성 검사 및 직렬화는 애플리케이션에서 작성되는 가장 많은 양의 코드입니다.</strong> 따라서 FastAPI를 사용하면 개발 시간, 버그, 코드 줄을 절약 할 수 있으며 사용하지 않았을 때와 동일한 성능 (또는 더 나은 성능)을 얻을 수 있습니다.</li>
    </ul>

    <p>## <strong>**FastAPI for Production</strong>**</p>

    <ul>
      <li><strong>Uvicorn-FastAPI</strong>에서 Uvicorn은 <strong>single process</strong>로만 작동합니다. 이 때문에 병렬성이 부족해져 multi process를 돌려야 하는 상황(병렬처리)에 대처할 수 없습니다. 때문에 <strong>Gunicorn</strong>을 통해 process를 동시에 여러개 돌려 병렬성을 확보합니다. 이를 통해 production 환경에서도 FastAPI가 높은 성능을 낼 수 있게 만들어줍니다.</li>
    </ul>

    <p>## <strong>**Gunicorn</strong>**</p>

    <p><strong>Gunicorn</strong>은 <strong>서버</strong>이자 <strong>프로세스</strong> 관리자입니다.</p>

    <p>Python web application을 production 환경에 deployment 할 때 일반적으로 세가지를 섞어서 사용합니다.</p>

    <ul>
      <li><strong>Web server</strong> (e.g. Nginx)</li>
      <li><strong>WSGI (web) server</strong> (e.g. Gunicorn)</li>
      <li><strong>Web application server</strong>(web app or web framwork) (e.g. Django)</li>
    </ul>

    <p>Web server는 요청을 수락하고 https 연결을 처리합니다. WSGI server는 web server의 요청을 받아 web application server에 전달합니다. Web applicatin server는 단일 요청을 처리 할 수 있다는 것 외에는 아무것도 신경 쓰지 않습니다.</p>

    <p>## <strong>**Gunicorn is a WSGI server</strong>**</p>

    <p>Gunicorn은 다양한 web server와 상호 작용할 수 있도록 구축되었습니다. Gunicorn은 web server와 web application 사이에서 일어나는 모든 일을 처리합니다. 이렇게하면 web application을 코딩 할 때 다음을위한 자체 솔루션을 찾을 필요가 없습니다.</p>

    <ul>
      <li>여러 web server와 통신</li>
      <li>한 번에 많은 request를 처리하고 부하를 분산</li>
      <li>실행중인 web application의 multi process 유지</li>
    </ul>

    <p>## <strong>**Uvicorn with Gunicorn</strong>**</p>

    <p>Uvicorn에는 Gunicorn worker class가 포함되어있어 Uvicorn의 모든 성능 이점과 함께 ASGI 애플리케이션을 실행할 수 있습니다.</p>

    <p>최종적으로 Gunicorn을 사용하여 Uvicorn을 관리하고 이를 통해 동시에 여러 process를 실행할 수 있습니다.</p>

    <p>## ASGI</p>

    <p>WSGI는 웹 서버와 Python Application 사이에 통신하기 위한 인터페이스이다.</p>

    <p>WSGI는 요청을 받고 응답을 반환하는 동작이 단일 동기 호출 방식으로 처리된다. 따라서 오랜 시간 연결을 유지하는 Websocket이나 긴 Http 요청을 처리하기에 적합하지 않다. → 웹 소켓을 통한 실시간 채팅 등의 서비스를 구현하는데 어려움이 있다.</p>

    <p>ASGI는 이 부분이 단일 비동기 호출이 가능하도록 설계되었다. 따라서 클라이언트로부터 여러 이벤트를 주고받을 수 있으며, 백그라운드 코루틴을 실행할 수 있게 되었다.</p>

    <p>## Uvicorn</p>

    <p>uvloop와 httptools 라는 것들을 사용하여 ASGI를 구현한 서버이다.</p>
  </li>
</ul>
:ET