---
title: Kubernetes - 쿠버네티스의 특징
categories: Tech
toc: true
toc_sticky: true
toc_label: k8s 특징 정리
---

# Kubernetes

![image](https://user-images.githubusercontent.com/63439911/196174608-3ad5f71c-86f4-4c4d-a8d2-f8056d8060bd.png)


전통적인 배포에서 초기 조직은 애플리케이션을 물리 서버에서 실행했다. 물리 서버를 많이 유지하기 위해서 조직에게 많은 비용이 들었다.

가상화된 배포에서는 많은 비용이 드는 전통적인 배포 방식의 단점을 해결하고 가상화를 도입했다. 이를 통해 단일 물리 서버의 CPU에서 여러 가상 시스템(VM)을 실행할 수 있게 했따. 또한 가상화를 통해 VM간에 애플리케이션을 격리하고 그 정보들을 다른 애플리케이션에서 자유롭게 엑세스 할 수 없기 때문에 일정 수준의 보안성이 제공된다.

또한 각각의 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신이다.

컨테이너 개발에는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제를 공유한다. 그렇기 떄문에 가볍다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리 프로세스 등의 공간이 있다. 

다음으로 컨테이너의 장점을 알아보면 다음과 같다.

- 기민하다.
    - VM 이미지를 사용하는 것에 비해 이미지 생성이 쉽고 효율적이다.
- 지속적인 개발 통합 및 배포
    - 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있다. 또한 효율적인 rollback이 가능하다.
- 개발과 운영의 분리
    - 배포 시점이 아니라 빌드/릴리스 시점에 컨테이너 이미지를 만들기 때문에 애플리케이션이 infrastructure에서 분리된다.
- 가시성
    - OS 수준의 정보와 메트릭에 머무르지 않는다.
- 일관성
    - 로컬환경, 클라우드 환경 모두 동일하게 구동된다.
- 클라우드 및 OS 배포판 간 이식성
    - Ubuntu, CoreOS, On-premise 어디서든 구동된다.
- 애플리케이션 중심 관리
    - 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아진다.
- 분산되고 유연하며 자유로운 마이크로서비스
    - 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 독립적인 단위로 쪼개져서 동적으로 배포하고 관리될 수 있다.
- 리소스 격리
    - 애플리케이션의 성능을 예측할 수 있다.
- 자원 사용량
    - 리소스 사용량이 고효율이다.
## K8s란?

단일 서버에서 도커를 사용하게 되면 오케스트레이션이라고 불리는 쿠버네티스를 사용할 이유가 없다. 그러나 두 개 이상의 서버에서 도커 데몬을 사용하게 된다면 idle 상태인 서버를 선택하여 해당 서버에 컨테이너를 생성해서 운영해야 한다. 이 때 k8s와 같은 오케스트레이션 툴이 필요하다.

- 오케스트레이션
    - 컨테이너의 수가 많아지면 관리와 운영에 어려움이 따르는데 이러한 다수의 컨테이너 실행을 관리 및 조율하는 시스템이다.

## K8s가 필요한 이유

프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다. → 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야하는데 이것을 자동으로 처리해야한다.

쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다. 애플리케이션의 확장과 장애 조치를 처리하고 배포 패턴 등을 제공한다.

쿠버네티스는 다음과 같은 것들을 제공한다.

- 서비스 디스커버리, 로드 밸런싱
    - 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출한다. 컨테이너에 대한 트래픽이 많으면 그것들을 로드밸런싱하여 배포가 안정적으로 이뤄지게 한다.
- 스토리지 오케스트레이션
    - 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탐재 가능하다.
- 자동화된 롤아웃과 롤백
    - 배포된 컨테이너의 원하는 상태를 서술하고 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. → 배포용 새 컨테이너를 만들고 기존 것을 제거하고 옮길 수 있다.
- 자동화된 빈 패킹
    - 각 컨테이너가 필요로 하는 CPU와 RAM을 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- 자동화된 복구
    - 실패한 컨테이너를 다시 시작하고 교체한다.
- 시크릿과 구성 관리
    - 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.
## K8s의 목적

### | 다중의 도커 서버를 하나의 Pool로 구성

K8s는 다중 서버의 도커 데몬에 연결하여 사용하는데 사용자는 사용하는 서버의 서버가 몇 개인지 도커 컨테이너가 몇 개 실행중인지 알 필요가 없다. 

단지 마스터에게 사용자가 필요한 컨테이너를 어떤 목적에 맞는 이미지로 몇 개 만들지만 명령하면 된다.

### | 다중 서버에 분산되어 컨테이너 생성
![image](https://user-images.githubusercontent.com/63439911/196420747-87fb2f40-45ef-4582-85ec-d2ebada342d9.png)
두 개의 워커 노드에 3개의 container를 생성하게 되면 쿠버네티스에서 알아서 컨테이너를 A서버와 B서버에게 할당한다. idle인 서버를 직접 찾지 않아도 된다.

### | A서버 B서버 와의 컨테이너 통신

각 서버 컨테이너는 각각의 private ip가 있는데 이러한 컨테이너들간의 통신은 kube-proxy 등을 통해 가능하다.

### | 컨테이너 재생성

서버에 문제가 생기거나 컨테이너가 exit 되는 경우 쿠버네티스는 이 상황을 방지하여 동일한 컨테이너를 생성하고 서비스를 지속적으로 제공한다.

### | Load Balance

kubernetes 클러스터로 생성된 웹사이트에 3개의 컨테이너가 동작하는데 그 웹사이트의 public ip로 사용자가 접근할 때마다 컨테이너 순서대로 접근할 수 있도록 round-robin 형태의 로드밸런싱이 제공된다.

## K8s 특징

쿠버네티스는 컨테이너 수준에서 운영되기 때문에 PaaS가 일반적으로 제공하는 배포, 스케일링, 로드 밸런싱과 같은 기능을 제공하며, 사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있다. 개발자가 플랫폼을 만드는 구성 요소를 제공하지만, 필요한 경우 사용자의 선택권과 유연성을 지켜준다.

- 쿠버네티스는 stateless, stateful, 데이터 처리를 위한 워크로드르 포함한 다양한 워크로드를 지원하는 것을 목표로 한다.
- 소스 코드를 배포하지 않으며 애플리케이션을 빌드하지 않는다. CI/CD 워크플로우는 조직 문화와 취향에 따르고 기술적인 요구사항으로 결정된다.
- 애플리케이션 레벨의 서비스를 제공하지 않는다. 애플리케이션 서비스에는 미들웨어, 데이터 처리 프레임워크, 데이터베이스, 캐시 또는 클러스터 스토리지 시스템 등이 있다.
- 로깅, 모니터링 또는 경보 솔루션을 포함하지 않는다.

쿠버네티스는 오케스트레이션의 필요성을 없애준다. 오케스트레이션이란 A를 먼저 한 다음 B를 하고 C를 하느 것과 같이 정의된 워크플로우를 수행하는 것이다.

쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성되어 있다. 이 프로세스는 지속적으로 현재 상태를 입력받은 의도한 상태로 나아가도록 한다. 이로써 시스템이 보다 더 사용하기 쉬워지고 강력해지며 견고하고 회복력을 갖추게 되며 확장 가능해진다.

## K8s 용어

- master
    - 마스터 노드이며 도커 데몬을 관리하는 역할
- worker
    - 도커가 설치되어 있으며 실제 컨테이너들이 생성되어 일하는 노드이다. master의 관리를 받는다.
- pod
    - k8s의 기본 단위이다. 컨테이너 혹은 컨테이너의 묶음이다.
- rc
    - replication controller로 pod를 자동으로 생성 복제해주는 컨트롤러이다. 복제 개수 설정을 3으로 하면 3개의 pod가 서비스상에 계속 active상태가 된다.
- service
    - pod의 group을 식별하는 라벨이라는 기준에 따라 pod들을 하나의 서비스로 외부에서 접근할 수 있게함
- yaml
    - k8s에서 service, rc, pod등 기능을 설명한 데이터 형식 코드이다.

## K8s 주요 도구
![image](https://user-images.githubusercontent.com/63439911/196420924-63e71c1c-69a4-4e14-a14d-d280644a5ea1.png)
- kubeadm: init(join), 초기화(Bootstrap)
    
    kubernetes 구성과 초기화 그리고 노드 확장할 때 외에는 사용하지 않지만 중요한 요소이다.
    
- kubectl : cmd 작업 수행, k8s object 생성,관리
## K8s pod
![image](https://user-images.githubusercontent.com/63439911/196421075-c91721f6-4da4-4e42-8a2a-acd51beaaf6c.png)
pod란 k8s의 기본적인 배포단위이며, 컨테이너를 포함한 단위이다. k8s의 특징 중 하나는 container를 개별적으로 하나씩 배포하는 것이 아니라 pod 단위로 배포한다.

## pod - replicaset
![image](https://user-images.githubusercontent.com/63439911/196421191-3bd38cda-0cb2-42c9-910d-86555a5b3bc5.png)![image](https://user-images.githubusercontent.com/63439911/196421216-c651d847-b2d6-4334-9324-9ecbed49da5b.png)
web container 2개 복제해서 띄어놓겠다고 정의하여 pod를 생성하게 되면 2개의 호스트에 container가 생성되어 서비스를 한다.

## 랜처
대규모 클러스터 및 기업용 환경에도 적합한 쿠버네티스 관리 플랫폼이다. 오픈소스이다. 

랜처의 가장 큰 장점으로는 쿠버네티스 클러스터뿐 아니라 운영에 필요한 모니터링, 보안 관련 기능을 쉽게 설치할 수 있다는 점이다. 랜처의 관리 도구를 사용해서 새로운 쿠버네티스 클러스터를 쉽게 생성하고 여러 클러스터를 한 곳에서 관리할 수 있다.
<img width="702" alt="image" src="https://user-images.githubusercontent.com/63439911/197162299-2cfa3078-7312-4d59-9daa-67cea8d88c6c.png">
랜처는 대규모 시스템 관리까지 염두에 둔 플랫폼이므로 자체적인 구성 요소가 많이 포함되어 있으며 이로 인해 다른 도구에 비해 더 무거운 단점이 있다. 

| 랜처의 특징

- 용도 : 대규모 기업용 환경에도 활용 가능한 다목적 쿠버네티스 관리 플랫폼
- 장점 : 기능이 많고 추가 도구 설치 용이, 멀티 클라우드 관리 가능
- 단점 : 다른 도구에 비해 무겁다.
